{"version":3,"sources":["styling/design/blocks/obstacle.png","components/header/toolbarSettings.js","styling/design/logo/iconfinder_path_103676.png","styling/design/blocks/startPoint.png","styling/design/blocks/endPoint.png","components/header/subTypes/logo.jsx","logic/grid/objectTypes.js","components/header/subTypes/obstacleToggle.jsx","logic/grid/cell.js","config.js","logic/grid/grid.js","logic/manager.js","logic/Algorithms/BaseAlgorithm.js","logic/Algorithms/pathFinding/algorithms/score-based/ScoreBasedAlgorithm.js","logic/Algorithms/pathFinding/algorithms/BasePathAlgorithm.js","logic/Algorithms/pathFinding/algorithms/score-based/AStar.js","logic/sleepUtility.js","logic/Algorithms/pathFinding/pathfinder.js","logic/Algorithms/pathFinding/algorithms/score-based/Dijkstra.js","logic/Algorithms/pathFinding/algorithms/score-based/Bidirectional.js","components/header/subTypes/pathAlgorithmSelect.jsx","logic/Algorithms/mazeGeneration/algorithms/BaseMazeAlgorithm.js","logic/grid/unitsHelper.js","logic/Algorithms/mazeGeneration/algorithms/RecursiveBacktracking.js","logic/Algorithms/mazeGeneration/mazeGenerator.js","logic/Algorithms/mazeGeneration/algorithms/EllerMazeAlgorithm.js","logic/Algorithms/mazeGeneration/algorithms/RecursiveDivisionAlgorithm.js","components/header/subTypes/mazeAlgorithmSelect.jsx","components/header/subTypes/simulationSpeedSelect.jsx","components/header/subTypes/simulatePathButton.jsx","components/header/subTypes/simulateMazeButton.jsx","components/header/subTypes/clearButton.jsx","components/header/header.jsx","logic/cellNamingUtility.js","components/grid/objects/startPoint.jsx","components/grid/objects/obstacle.jsx","components/grid/objects/endPoint.jsx","components/grid/objects/objectDrawer.jsx","components/grid/cell.jsx","components/grid/grid.jsx","serviceWorker.js","index.js","components/App.js"],"names":["module","exports","drawingObjectType","getSafeDrawingType","setDrawingType","value","Logo","src","logo","alt","className","cellObjects","empty","startPoint","endPoint","obstacle","toolbarSettings","require","ObstacleToggle","props","React","useState","isSelected","setSelected","ToggleButton","selected","onChange","newSelectedValue","ObjectType","disabled","isUsable","obstacleIcon","neighborPossibilities","x","y","direction","Cell","grid","index","this","_objectType","ObjectTypes","resetCellColor","cellColor","objectType","_cellColor","spaceMultiplier","neighbors","neighborPossibility","neighbor","getNeighbor","push","cell","getNeighborAtUnitsDirection","find","units","isInBounds","getCell","cachedObjectType","onCellModified","oldType","desktop","width","height","mobile","defaultItems","simulationPlaybackDelay","rewind","rewindColor","routeColor","getRndBackend","isMobile","TouchRNDBackend","DesktopRNDBackend","getGridCoords","EventEmitter","Grid","spawnDefault","eventEmitter","isSimulated","cells","row","column","transformUnitsToIndex","spawnDefaultItems","map","spawnItems","Config","spawnItem","Math","floor","emitTarget","additionalData","undefined","Error","emit","rowId","startOffset","endOffset","spaceOffset","rowCells","i","console","error","targetCellUnits","currentCell","getCellWithObjectType","targetCell","gridSize","BaseAlgorithm","prepareCellForAlgorithmCalculation","ScoreBasedAlgorithm","willRewindRoute","tracedRoute","t0","Date","now","rewindStack","prepareForAlgorithmCalculation","unvisited","visited","findSmallestScoreCell","cellNeighbors","getNeighbors","isNeighborTheTarget","filter","neighborCell","neighborPathData","pathData","includes","score","calculateScore","isNeighborCalculated","addCellToUnvisited","prev","length","tracebackRoute","t1","log","smallestScoreCell","currCell","route","isPath","reverse","AStar","g","newScore","abs","currentNeighborScore","sleep","ms","Promise","resolve","setTimeout","pathFinder","pathFindingAlgorithm","AStarAlgorithm","pathGenerated","simulatePath","a","Manager","setSimulationState","calculateRoute","simulateRewind","simulatePathVisuals","clearPath","rewindRoute","delay","res","unshift","resetColorPromise","renderTrailPromise","secRes","all","Dijkstra","BidirectionalAlgorithm","set","setCellSet","currCellSet","neighborCellSet","markPrevAsPath","pathNeighbor","algorithms","DijkstraAlgorithm","PathAlgorithmSelect","selectedAlgo","setAlgo","FormControl","Select","labelId","id","event","target","PathFinder","MenuItem","BaseMazeAlgorithm","passageCarver","clearAllObjects","mazeData","sample","cellA","cellB","dirX","dirY","clampDirectionToOne","RecursiveBacktracking","recursiveMove","openCells","stack","movableNeighbors","isValidMove","pop","randomMoveCell","inBetweenCell","getCellBetweenCells","currentAlgorithm","RecruisiveBacktracing","generateMaze","algorithm","drawRewind","passageCarverRewind","wallAdderRewind","EllersAlgorithm","generateRow","cellsToSets","sets","setsCounter","getRowCells","rowBelow","isLastRow","assignSetsToUnassignedCells","combineAdjacentCellsInRow","combineVerticalCellsInRowUnder","hasOwnProperty","addToSet","nextCell","getRndTrueFalse","nextCellSet","mergeSets","betweenCell","currRowId","rowBelowId","setCells","verticalConnections","copiedSetCells","cellIndex","belowCell","fromSet","toSet","fromSetCells","toSetCells","fromSetCell","random","RecursiveDivisionAlgorithm","horizontal","vertical","maxDetail","closeOffAllBoarders","simpleRecursiveMove","initialRun","determineCrossDirection","orientation","wx","getRand","wy","px","py","areUnitsAllowed","nx","ny","nw","nh","max","isHorizontal","RecrusiveBacktrackingAlgorithm","EllerMazeAlgorithm","MazeAlgorithmSelect","MazeGenerator","speeds","SimulationSpeedSelect","selectedSpeed","setSelectedSpeed","SimulatePathButton","Button","variant","color","onClick","SimulateMazeButton","ClearButton","clearObjects","HeaderComponent","getCellDOMId","StartPoint","useDrag","item","type","collect","monitor","isDragging","drag","ref","style","opacity","cursor","Obstacle","EndPoint","CellObjectDrawer","object","cellWidth","marginSpace","window","innerWidth","useStyle","makeStyles","root","marginLeft","left","data","top","CellComponent","useDrop","accept","drop","dropProps","moveItemToCell","canDrop","handlePaintObject","isHoldingMouse","cssClasses","onMouseMove","e","buttons","GridComponent","logicCells","simplify","state","on","cellId","document","getElementById","backgroundColor","setState","Pathfinder","DndProvider","backend","key","Component","Boolean","location","hostname","match","ReactDOM","render","setIsUsable","useEffect","simulating","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.821f609e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/obstacle.7bf64a37.png\";","let drawingObjectType = 0;\r\n\r\nmodule.exports = {\r\n  drawingObjectType,\r\n  getSafeDrawingType: () => {\r\n    return this.drawingObjectType || \"empty\";\r\n  },\r\n  setDrawingType: value => {\r\n    this.drawingObjectType = value;\r\n  }\r\n};\r\n","module.exports = __webpack_public_path__ + \"static/media/iconfinder_path_103676.d2fdd691.png\";","module.exports = __webpack_public_path__ + \"static/media/startPoint.b2d3c123.png\";","module.exports = \"data:image/png;base64,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\"","import React from \"react\";\r\nimport logo from \"../../../styling/design/logo/iconfinder_path_103676.png\";\r\n\r\nexport default function Logo() {\r\n  return <img src={logo} alt=\"path finding demo\" className=\"Logo\"></img>;\r\n}\r\n","const cellObjects = {\r\n  empty: \"empty\",\r\n  startPoint: \"startPoint\",\r\n  endPoint: \"endPoint\",\r\n  obstacle: \"obstacle\"\r\n};\r\n\r\nexport default cellObjects;\r\n","import React from \"react\";\r\n\r\nimport obstacleIcon from \"../../../styling/design/blocks/obstacle.png\";\r\nimport ToggleButton from \"@material-ui/lab/ToggleButton\";\r\n\r\nimport ObjectType from \"../../../logic/grid/objectTypes\";\r\n\r\nconst toolbarSettings = require(\"../toolbarSettings\");\r\n\r\nexport default function ObstacleToggle(props) {\r\n  const [isSelected, setSelected] = React.useState(false);\r\n\r\n  const handleChange = () => {\r\n    const newSelectedValue = !isSelected;\r\n\r\n    setSelected(newSelectedValue);\r\n    toolbarSettings.setDrawingType(newSelectedValue ? ObjectType.obstacle : 0);\r\n  };\r\n\r\n  return (\r\n    <ToggleButton\r\n      value=\"check\"\r\n      selected={isSelected}\r\n      onChange={handleChange}\r\n      className=\"ToggleBox MiddleItem\"\r\n      disabled={!props.isUsable}\r\n    >\r\n      <img\r\n        alt=\"place obstacles\"\r\n        src={obstacleIcon}\r\n        className=\"ToggleButton\"\r\n      ></img>\r\n    </ToggleButton>\r\n  );\r\n}\r\n","import ObjectTypes from \"./objectTypes\";\r\n\r\nconst neighborPossibilities = [\r\n  { x: 0, y: 1, direction: \"top\" }, // top\r\n  { x: 0, y: -1, direction: \"bottom\" }, // bottom\r\n  { x: 1, y: 0, direction: \"right\" }, // right\r\n  { x: -1, y: 0, direction: \"left\" } // left\r\n];\r\n\r\nclass Cell {\r\n  constructor(grid, x, y, index) {\r\n    this.grid = grid;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.index = index;\r\n\r\n    this._objectType = ObjectTypes.empty;\r\n    this.resetCellColor();\r\n  }\r\n\r\n  //#region get;set; accessors\r\n\r\n  get objectType() {\r\n    return this._objectType;\r\n  }\r\n\r\n  set objectType(value) {\r\n    if (!(typeof value === \"string\")) return;\r\n\r\n    // keep the old type in memory so we can launch that in the event\r\n    const cachedObjectType = this._objectType;\r\n\r\n    this._objectType = value;\r\n\r\n    this.grid.onCellModified(this, \"objectChange\", {\r\n      oldType: cachedObjectType\r\n    }); // recalculate path and redraw object!\r\n  }\r\n\r\n  get cellColor() {\r\n    return this._cellColor;\r\n  }\r\n\r\n  set cellColor(value) {\r\n    if (!(typeof value === \"string\")) return;\r\n\r\n    this._cellColor = value;\r\n    this.grid.onCellModified(this, \"colorChange\");\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region general methods\r\n\r\n  resetCellColor() {\r\n    const defaultColor = \"rgb(237, 245, 225)\";\r\n\r\n    if (this.cellColor === defaultColor) return;\r\n    this.cellColor = defaultColor;\r\n  }\r\n\r\n  simplify() {\r\n    const { x, y, objectType, _cellColor } = this;\r\n    return { x, y, objectType, cellColor: _cellColor };\r\n  }\r\n\r\n  getNeighbors(spaceMultiplier = 1) {\r\n    const neighbors = [];\r\n\r\n    for (let neighborPossibility of neighborPossibilities) {\r\n      const neighbor = this.getNeighbor(neighborPossibility, spaceMultiplier);\r\n      if (!neighbor) continue;\r\n\r\n      neighbors.push(neighbor);\r\n    }\r\n\r\n    return neighbors;\r\n  }\r\n\r\n  getNeighbor(neighborPossibility, spaceMultiplier = 1) {\r\n    if (!neighborPossibility) return undefined;\r\n\r\n    const cell = this.getNeighborAtUnitsDirection(\r\n      neighborPossibility.x * spaceMultiplier,\r\n      neighborPossibility.y * spaceMultiplier\r\n    );\r\n\r\n    if (!cell) return undefined;\r\n\r\n    return {\r\n      cell,\r\n      direction: neighborPossibility.direction\r\n    };\r\n  }\r\n\r\n  getNeighborAtDirection(direction) {\r\n    const neighborPossibility = neighborPossibilities.find(\r\n      x => x.direction === direction\r\n    );\r\n\r\n    return this.getNeighbor(neighborPossibility);\r\n  }\r\n\r\n  getNeighborAtUnitsDirection(x, y) {\r\n    let units = {\r\n      x: this.x + x,\r\n      y: this.y + y\r\n    };\r\n\r\n    if (!this.grid.isInBounds(units.x, units.y)) return undefined;\r\n\r\n    return this.grid.getCell(units.x, units.y);\r\n  }\r\n\r\n  ////#endregion\r\n}\r\n\r\nexport default Cell;\r\n","import { isMobile } from \"react-device-detect\";\r\nimport DesktopRNDBackend from \"react-dnd-html5-backend\";\r\nimport TouchRNDBackend from \"react-dnd-touch-backend\";\r\n\r\nconst simulationPlaybackDelay = 10;\r\n\r\nexport default {\r\n  // note that Strict Blockwise mazes require uneven cell count\r\n  grid: {\r\n    desktop: {\r\n      width: 37,\r\n      height: 13\r\n    },\r\n    mobile: {\r\n      width: 15,\r\n      height: 13\r\n    },\r\n    defaultItems: [\r\n      { x: 0.9, y: 0.1, objectType: \"startPoint\" },\r\n      { x: 0.1, y: 0.75, objectType: \"endPoint\" },\r\n      { x: 0.25, y: 0.1, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.2, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.3, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.4, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.5, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.7, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.8, objectType: \"obstacle\" },\r\n      { x: 0.25, y: 0.9, objectType: \"obstacle\" }\r\n    ],\r\n    simulationPlaybackDelay\r\n  },\r\n  rewind: {\r\n    rewindColor: \"rgb(256, 256,0)\",\r\n    routeColor: \"rgb(72,209,204)\"\r\n  },\r\n  getRndBackend: function() {\r\n    return isMobile ? TouchRNDBackend : DesktopRNDBackend;\r\n  },\r\n  getGridCoords: function() {\r\n    return isMobile ? this.grid.mobile : this.grid.desktop;\r\n  }\r\n};\r\n","import Cell from \"./cell\";\r\nimport Config from \"../../config\";\r\n\r\nimport ObjectTypes from \"./objectTypes\";\r\n\r\nconst EventEmitter = require(\"events\");\r\n\r\nclass Grid {\r\n  eventEmitter = new EventEmitter();\r\n  isSimulated = false;\r\n\r\n  //#region initializers\r\n\r\n  constructor(width, height, spawnDefault) {\r\n    // generate the cells\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    this.cells = [];\r\n\r\n    for (let row = 0; row < height; row++) {\r\n      for (let column = 0; column < width; column++) {\r\n        const index = this.transformUnitsToIndex(column, row);\r\n\r\n        this.cells.push(new Cell(this, column, row, index));\r\n      }\r\n    }\r\n\r\n    // assign default objects\r\n    if (!spawnDefault) return;\r\n    this.spawnDefaultItems();\r\n  }\r\n\r\n  clearObjects() {\r\n    this.cells.map(x => (x.objectType = ObjectTypes.empty));\r\n  }\r\n\r\n  spawnDefaultItems() {\r\n    const spawnItems = Config.grid.defaultItems;\r\n\r\n    for (let spawnItem of spawnItems) {\r\n      const x = Math.floor(spawnItem.x * this.width);\r\n      const y = Math.floor(spawnItem.y * this.height);\r\n\r\n      this.getCell(x, y).objectType = spawnItem.objectType;\r\n    }\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region cell helpers\r\n\r\n  onCellModified(cell, emitTarget, additionalData = undefined) {\r\n    if (!emitTarget || !(typeof emitTarget === \"string\")) {\r\n      throw new Error(\"emit target isn't specified/ isn't a string!\");\r\n    }\r\n\r\n    this.eventEmitter.emit(\r\n      emitTarget,\r\n      cell,\r\n      this.transformUnitsToIndex(cell.x, cell.y),\r\n      additionalData\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Provide a x, y unit and get an index of a 1D array back.\r\n   * @param x the x coordinate of a unit\r\n   * @param y the y coordinate of a unit\r\n   */\r\n  transformUnitsToIndex(x, y) {\r\n    return x + y * this.width;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Get all of the cells in a row\r\n   *\r\n   * @param rowId\r\n   * @param startOffset\r\n   * @param endOffset\r\n   * @param spaceOffset space the cell retrieval (for instance, in blockwise we aim to get cells in spaces of two)\r\n   */\r\n  getRowCells(\r\n    rowId,\r\n    startOffset = undefined,\r\n    endOffset = undefined,\r\n    spaceOffset = 1\r\n  ) {\r\n    if (rowId < 0 || rowId > this.height) {\r\n      console.error(\"row id is out of bounds\");\r\n      return undefined;\r\n    }\r\n\r\n    startOffset = startOffset || 0;\r\n    endOffset = endOffset || this.width;\r\n\r\n    const rowCells = [];\r\n\r\n    for (let i = startOffset; i < endOffset; i += spaceOffset) {\r\n      const cell = this.getCell(i, rowId);\r\n      if (cell === undefined) continue;\r\n\r\n      rowCells.push(cell);\r\n    }\r\n\r\n    return rowCells;\r\n  }\r\n\r\n  getCell(x, y) {\r\n    if (!this.isInBounds(x, y)) return undefined;\r\n\r\n    const index = this.transformUnitsToIndex(x, y);\r\n    return this.cells[index];\r\n  }\r\n\r\n  getCellWithObjectType(objectType) {\r\n    return this.cells.find(x => x.objectType === objectType);\r\n  }\r\n\r\n  isInBounds(x, y) {\r\n    const { width, height } = this;\r\n\r\n    return x >= 0 && x < width && y >= 0 && y < height;\r\n  }\r\n\r\n  //#endregion\r\n\r\n  //#region cell moving/ removal\r\n\r\n  setSimulationState(value) {\r\n    if (this.isSimulated === value) return;\r\n\r\n    this.isSimulated = value;\r\n    this.eventEmitter.emit(\"simulateChanged\", value);\r\n  }\r\n\r\n  clearAllObjects(objectType) {\r\n    for (let cell of this.cells) {\r\n      if (cell.objectType !== objectType) continue;\r\n\r\n      cell.objectType = ObjectTypes.empty;\r\n    }\r\n  }\r\n\r\n  moveItemToCell(objectType, targetCellUnits) {\r\n    if (!objectType || !targetCellUnits)\r\n      throw new Error(\r\n        \"parameters weren't specified properly! can't process move items handler\"\r\n      );\r\n\r\n    const currentCell = this.getCellWithObjectType(objectType);\r\n    if (!currentCell)\r\n      throw new Error(\r\n        \"can't find current cell with object type \" +\r\n          objectType +\r\n          \" can't process drop handler\"\r\n      );\r\n\r\n    const targetCell = this.getCell(targetCellUnits.x, targetCellUnits.y);\r\n    if (!targetCell)\r\n      throw new Error(\"can't find the target cell. can't process drop handler\");\r\n\r\n    currentCell.objectType = ObjectTypes.empty;\r\n    targetCell.objectType = objectType;\r\n  }\r\n\r\n  //#endregion\r\n}\r\n\r\nexport default Grid;\r\n","import Grid from \"./grid/grid\";\r\nimport Config from \"../config\";\r\n\r\nconst gridSize = Config.getGridCoords();\r\nconst grid = new Grid(gridSize.width, gridSize.height, true);\r\n\r\nexport default {\r\n  grid\r\n};\r\n","import ObjectTypes from \"../grid/objectTypes\";\r\n\r\n/**\r\n * Base class for all algorithms, provides some good starting ground\r\n */\r\nexport default class BaseAlgorithm {\r\n  prepareForAlgorithmCalculation(grid) {\r\n    // prepare cells\r\n    for (let cell of grid.cells) {\r\n      this.prepareCellForAlgorithmCalculation(cell);\r\n    }\r\n\r\n    const startPoint = grid.getCellWithObjectType(ObjectTypes.startPoint);\r\n    const endPoint = grid.getCellWithObjectType(ObjectTypes.endPoint);\r\n\r\n    return {\r\n      startPoint,\r\n      endPoint\r\n    };\r\n  }\r\n\r\n  prepareCellForAlgorithmCalculation(cell) {}\r\n}\r\n","import BasePathAlgorithm from \"../BasePathAlgorithm\";\r\nimport ObjectTypes from \"../../../../grid/objectTypes\";\r\n\r\nexport default class ScoreBasedAlgorithm extends BasePathAlgorithm {\r\n  calculateRoute(grid, willRewindRoute) {\r\n    const t0 = Date.now();\r\n    const rewindStack = [];\r\n    let tracedRoute = undefined;\r\n\r\n    let {\r\n      unvisited,\r\n      visited,\r\n      startPoint,\r\n      endPoint\r\n    } = this.prepareForAlgorithmCalculation(grid);\r\n\r\n    while (unvisited.length > 0) {\r\n      const cell = this.findSmallestScoreCell(unvisited);\r\n      const cellNeighbors = cell.getNeighbors();\r\n\r\n      // if we have the end point in our neighbors then we won!\r\n      if (cellNeighbors.find(neighbor => this.isNeighborTheTarget(cell, neighbor, endPoint))) {\r\n        break;\r\n      }\r\n\r\n      unvisited = unvisited.filter(x => x !== cell); // remove from unvisited as we are calculating it now\r\n      visited.push(cell); // add cell to visited\r\n\r\n      for (let neighbor of cellNeighbors) {\r\n        const neighborCell = neighbor.cell;\r\n        const neighborPathData = neighborCell.pathData;\r\n\r\n        // ignore obstacles and already visited cells\r\n        if (\r\n          neighborCell.objectType === ObjectTypes.obstacle ||\r\n          visited.includes(neighborCell)\r\n        )\r\n          continue;\r\n\r\n        // calculate neighbor score\r\n        const score = this.calculateScore(cell, neighborCell, endPoint);\r\n        const isNeighborCalculated = neighborPathData.score > 0;\r\n\r\n        // if this neighbor was already calculated and the old calculatioin score\r\n        // is smaller than what we just did, no need to calculate again!\r\n        if (isNeighborCalculated && neighborPathData.score <= score) continue;\r\n\r\n        if (!isNeighborCalculated) {\r\n          this.addCellToUnvisited(cell, neighborCell, unvisited);\r\n        }\r\n\r\n        neighborPathData.score = score;\r\n        neighborPathData.prev = cell;\r\n\r\n        if (!willRewindRoute) continue;\r\n        rewindStack.push(neighborCell);\r\n      }\r\n    }\r\n\r\n    tracedRoute = this.tracebackRoute(startPoint, endPoint);\r\n\r\n    const t1 = Date.now();\r\n\r\n    console.log(\"It took \" + (t1 - t0) + \" milliseconds to compute path!\");\r\n\r\n    return {\r\n      tracedRoute,\r\n      rewindStack,\r\n      startPoint,\r\n      endPoint\r\n    };\r\n  }\r\n\r\n  calculateScore(cell, neighborCell, endPoint) {\r\n    return undefined;\r\n  }\r\n\r\n  prepareCellForAlgorithmCalculation(cell) {\r\n    super.prepareCellForAlgorithmCalculation(cell);\r\n\r\n    // set score.\r\n    cell.pathData.score = 0;\r\n  }\r\n\r\n  findSmallestScoreCell(cells) {\r\n    if (cells.length === 1) return cells[0];\r\n\r\n    let smallestScoreCell = undefined;\r\n    for (let i = cells.length - 1; i >= 0; i--) {\r\n      const cell = cells[i];\r\n\r\n      // check if we have a smallest score assigned and if so, if the current one is higer, continue\r\n      if (\r\n        smallestScoreCell &&\r\n        cell.pathData.score >= smallestScoreCell.pathData.score\r\n      )\r\n        continue;\r\n\r\n      smallestScoreCell = cell;\r\n    }\r\n\r\n    return smallestScoreCell;\r\n  }\r\n\r\n  isNeighborTheTarget(currCell, neighbor, endPoint) {\r\n    const isEndTarget = neighbor.cell === endPoint;\r\n\r\n    if (!isEndTarget) return false;\r\n\r\n    // set the prev cell of the neighbor (ie end point) to the current cell!\r\n    neighbor.cell.pathData.prev = currCell;\r\n    return true;\r\n  }\r\n\r\n  addCellToUnvisited(cell, neighborCell, unvisited) {\r\n    unvisited.push(neighborCell);\r\n  }\r\n}","import BaseAlgorithm from \"../../BaseAlgorithm\";\r\n\r\n/**\r\n * Base class for all path algorithms\r\n */\r\nexport default class BasePathAlgorithm extends BaseAlgorithm {\r\n  calculateRoute(grid, willRewindRoute) {\r\n    return undefined;\r\n  }\r\n\r\n  calculateScore(cell, neighborCell, endPoint) {\r\n    return undefined;\r\n  }\r\n\r\n  prepareForAlgorithmCalculation(grid) {\r\n    const {\r\n      startPoint,\r\n      endPoint\r\n    } = super.prepareForAlgorithmCalculation(grid);\r\n\r\n    const unvisited = [startPoint];\r\n    const visited = [];\r\n\r\n    return {\r\n      unvisited,\r\n      visited,\r\n      startPoint,\r\n      endPoint\r\n    };\r\n  }\r\n\r\n  prepareCellForAlgorithmCalculation(cell) {\r\n    super.prepareCellForAlgorithmCalculation(cell);\r\n\r\n    cell.resetCellColor();\r\n    cell.pathData = {};\r\n  }\r\n\r\n  tracebackRoute(startPoint, endPoint) {\r\n    if (!startPoint || !endPoint || !endPoint.pathData.prev) return;\r\n\r\n    const route = [];\r\n\r\n    let prev = endPoint;\r\n    while (prev) {\r\n      route.push(prev);\r\n      prev.pathData.isPath = true;\r\n\r\n      prev = prev.pathData.prev;\r\n    }\r\n\r\n    return route.reverse();\r\n  }\r\n}","import ScoreBasedAlgorithm from \"./ScoreBasedAlgorithm\";\r\n\r\n/**\r\n * This is the extension for AStar algorithm.\r\n * Mostly the same as Dijkstra but the main difference is that instead of using a generic score (prev cost + 1)\r\n * it uses G and H to calculate a more accurate path.\r\n *\r\n * G -> movement cost (tile distance from origin, increases by one each time)\r\n * H -> estimated distance from cell to end point (simple solution -> city block distance)\r\n */\r\nexport default class AStar extends ScoreBasedAlgorithm {\r\n  calculateScore(cell, neighborCell, endPoint) {\r\n    const g = cell.pathData.g + 1;\r\n    const h = Math.abs(\r\n      endPoint.x - neighborCell.x + (endPoint.y - neighborCell.y)\r\n    );\r\n\r\n    const newScore = g + h;\r\n\r\n    const currentNeighborScore = neighborCell.pathData.score;\r\n    if (currentNeighborScore === 0 || newScore < currentNeighborScore) {\r\n      neighborCell.pathData.g = g;\r\n    }\r\n\r\n    return newScore;\r\n  }\r\n\r\n  prepareCellForAlgorithmCalculation(cell) {\r\n    super.prepareCellForAlgorithmCalculation(cell);\r\n\r\n    cell.pathData.g = 0;\r\n  }\r\n}\r\n","export default function sleep(ms) {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n","import Manager from \"../../manager\";\r\n\r\nimport AStarAlgorithm from \"./algorithms/score-based/AStar\";\r\nimport sleep from \"../../sleepUtility\";\r\n\r\nimport Config from \"../../../config\";\r\n\r\nconst pathFindingAlgorithm = new AStarAlgorithm();\r\nconst pathGenerated = false;\r\n\r\nconst simulatePath = async function (willRewindRoute = false) {\r\n  if (!this.pathFindingAlgorithm) return;\r\n\r\n  Manager.grid.setSimulationState(true);\r\n\r\n  const grid = Manager.grid;\r\n\r\n  const {\r\n    tracedRoute,\r\n    rewindStack,\r\n    startPoint,\r\n    endPoint\r\n  } = this.pathFindingAlgorithm.calculateRoute(grid, willRewindRoute);\r\n\r\n  if (willRewindRoute) {\r\n    await this.simulateRewind(startPoint, endPoint, rewindStack, tracedRoute);\r\n  } else {\r\n    this.simulatePathVisuals(grid);\r\n  }\r\n\r\n  this.pathGenerated = true;\r\n  Manager.grid.setSimulationState(false);\r\n\r\n  return tracedRoute;\r\n};\r\n\r\nconst clearPath = function () {\r\n  if (!this.pathFindingAlgorithm) return;\r\n\r\n  this.pathFindingAlgorithm.prepareForAlgorithmCalculation(Manager.grid); // clear all current path finding simulations\r\n  this.pathGenerated = false;\r\n};\r\n\r\n//#region Visuals\r\n\r\nconst simulatePathVisuals = function (grid) {\r\n  for (let cell of grid.cells) {\r\n    if (!cell.pathData.isPath) continue;\r\n\r\n    cell.cellColor = Config.rewind.routeColor;\r\n  }\r\n};\r\n\r\nconst simulateRewind = function (startPoint, endPoint, rewindRoute, tracedRoute) {\r\n  const delay = Config.grid.simulationPlaybackDelay;\r\n\r\n  return new Promise(async res => {\r\n    rewindRoute.unshift(startPoint); // add start point to beginning\r\n    rewindRoute.push(endPoint); // add end point to end\r\n\r\n    for (let cell of rewindRoute) {\r\n      cell.cellColor = Config.rewind.rewindColor;\r\n      await sleep(delay);\r\n    }\r\n\r\n    // this will turn off the rewind route\r\n    const resetColorPromise = new Promise(async res => {\r\n      for (let cell of rewindRoute) {\r\n        if (cell.pathData.isPath) continue;\r\n\r\n        cell.resetCellColor();\r\n        await sleep(delay);\r\n      }\r\n      res();\r\n    });\r\n\r\n    // this will show the actual end route\r\n    const renderTrailPromise = new Promise(async secRes => {\r\n      for (let cell of tracedRoute) {\r\n        if (!cell) break;\r\n\r\n        cell.cellColor = Config.rewind.routeColor;\r\n\r\n        await sleep(100);\r\n      }\r\n      secRes();\r\n    });\r\n\r\n    await Promise.all([resetColorPromise, renderTrailPromise]);\r\n\r\n    res();\r\n  });\r\n};\r\n\r\n//#endregion\r\n\r\nconst pathFinder = {\r\n  pathFindingAlgorithm,\r\n  pathGenerated,\r\n  simulatePath,\r\n  clearPath,\r\n  simulatePathVisuals,\r\n  simulateRewind\r\n};\r\n\r\nexport default pathFinder;","import ScoreBasedAlgorithm from \"./ScoreBasedAlgorithm\";\r\n\r\nexport default class Dijkstra extends ScoreBasedAlgorithm {\r\n  calculateScore(cell, neighborCell, endPoint) {\r\n    return cell.pathData.score + 1;\r\n  }\r\n}\r\n","import ScoreBasedAlgorithm from \"./ScoreBasedAlgorithm\";\r\n\r\nexport default class BidirectionalAlgorithm extends ScoreBasedAlgorithm {\r\n\r\n\r\n    /**\r\n     * \r\n     * Add sets to start & end point and also add end point to the unvisited cells to start simulation from it as well.\r\n     * \r\n     * @param  grid \r\n     */\r\n    prepareForAlgorithmCalculation(grid) {\r\n        const {\r\n            unvisited,\r\n            visited,\r\n            startPoint,\r\n            endPoint\r\n        } = super.prepareForAlgorithmCalculation(grid);\r\n\r\n        unvisited.push(endPoint); // add unpoint to unvisited as well!\r\n\r\n        // give the two points different sets!\r\n        startPoint.pathData.set = 1;\r\n        endPoint.pathData.set = 2;\r\n\r\n        return {\r\n            unvisited,\r\n            visited,\r\n            startPoint,\r\n            endPoint\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Dikstra implementation\r\n     * \r\n     * @param cell \r\n     * @param neighborCell \r\n     * @param endPoint \r\n     */\r\n    calculateScore(cell, neighborCell, endPoint) {\r\n        return cell.pathData.score + 1;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * when adding a cell to the unvisited array lets also give him our set!\r\n     * \r\n     * @param cell current cell\r\n     * @param neighborCell the neighbor cell we hit\r\n     * @param unvisited the unvisited cells array\r\n     */\r\n    addCellToUnvisited(cell, neighborCell, unvisited) {\r\n        super.addCellToUnvisited(cell, neighborCell, unvisited);\r\n        this.setCellSet(neighborCell, cell.pathData.set);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * give a cell a set \r\n     * \r\n     * @param cell the target cell \r\n     * @param set the set you want to assign\r\n     */\r\n    setCellSet(cell, set) {\r\n        cell.pathData.set = set;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param currCell the current cell\r\n     * @param neighbor the neighbor\r\n     * @param endPoint the end point  \r\n     */\r\n    isNeighborTheTarget(currCell, neighbor, endPoint) {\r\n        const {\r\n            set: currCellSet\r\n        } = currCell.pathData;\r\n        const {\r\n            set: neighborCellSet\r\n        } = neighbor.cell.pathData;\r\n\r\n        const isConnectionBridge = neighborCellSet && currCellSet !== neighborCellSet;\r\n        if (!isConnectionBridge) return false;\r\n\r\n        // lets mark the end points and their previous as marks\r\n        this.markPrevAsPath(currCell);\r\n        this.markPrevAsPath(neighbor.cell);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Mark all of the cells before this cell as paths!\r\n     * @param currCell \r\n     */\r\n    markPrevAsPath(currCell) {\r\n        let prev = currCell;\r\n\r\n        while (prev) {\r\n            const {\r\n                pathData\r\n            } = prev;\r\n\r\n            pathData.isPath = true;\r\n            prev = pathData.prev;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Get the route from start point to end point by connecting the dikstra path from each one\r\n     * \r\n     * @param startPoint \r\n     * @param endPoint \r\n     */\r\n    tracebackRoute(startPoint, endPoint) {\r\n        if (!endPoint || !startPoint) return undefined;\r\n\r\n        const route = [];\r\n\r\n        let currentCell = startPoint;\r\n        while (currentCell) {\r\n\r\n            route.push(currentCell);\r\n\r\n            const pathNeighbor = currentCell.getNeighbors().find(({\r\n                cell\r\n            }) => cell.pathData.isPath && !route.includes(cell))\r\n\r\n            // no path cells left\r\n            if (!pathNeighbor) break;\r\n\r\n            currentCell = pathNeighbor.cell;\r\n        }\r\n\r\n        return route;\r\n    }\r\n}","import React from \"react\";\r\n\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport FormControl from \"@material-ui/core/FormControl\";\r\nimport Select from \"@material-ui/core/Select\";\r\n\r\nimport PathFinder from \"../../../logic/Algorithms/pathFinding/pathfinder\";\r\nimport AStarAlgorithm from \"../../../logic/Algorithms/pathFinding/algorithms/score-based/AStar\";\r\nimport DijkstraAlgorithm from \"../../../logic/Algorithms/pathFinding/algorithms/score-based/Dijkstra\";\r\nimport BidirectionalAlgorithm from \"../../../logic/Algorithms/pathFinding/algorithms/score-based/Bidirectional\";\r\n\r\nconst algorithms = [new AStarAlgorithm(), new DijkstraAlgorithm(), new BidirectionalAlgorithm()];\r\n\r\nexport default function PathAlgorithmSelect(props) {\r\n  const [selectedAlgo, setAlgo] = React.useState(0);\r\n\r\n  const changeHandler = event => {\r\n    setAlgo(event.target.value);\r\n\r\n    PathFinder.pathFindingAlgorithm = algorithms[event.target.value];\r\n\r\n    // resimulate\r\n    if (!PathFinder.pathGenerated) return;\r\n    PathFinder.simulatePath();\r\n  };\r\n\r\n  return (\r\n    <FormControl className=\"SelectForm MiddleItem\">\r\n      <Select\r\n        labelId=\"algorithm-selector\"\r\n        id=\"algorithm-selector-select\"\r\n        value={selectedAlgo}\r\n        onChange={changeHandler}\r\n        className=\"SelectBox\"\r\n        disabled={!props.isUsable}\r\n      >\r\n        <MenuItem value={0} className=\"SelectMenuItem\">\r\n          A*\r\n        </MenuItem>\r\n        <MenuItem value={1} className=\"SelectMenuItem\">\r\n          Dijkstra\r\n        </MenuItem>\r\n        <MenuItem value={2} className=\"SelectMenuItem\">\r\n          Bi-Directional\r\n        </MenuItem>\r\n      </Select>\r\n    </FormControl>\r\n  );\r\n}\r\n","import sample from \"lodash.sample\";\r\nimport { clampDirectionToOne } from \"../../../grid/unitsHelper\";\r\n\r\nimport ObjectTypes from \"../../../grid/objectTypes\";\r\nimport BaseAlgorithm from \"../../BaseAlgorithm\";\r\n\r\nexport default class BaseMazeAlgorithm extends BaseAlgorithm {\r\n  /**\r\n   * What this means is whether the algorithm is the type of algorithm that starts with all walls closed and\r\n   * graudally opens them. If set to false, it means that the algorithm starts with an empty scene and gradually adds walls to it\r\n   */\r\n  passageCarver = true;\r\n\r\n  /**\r\n   *\r\n   * A base class for all future maze algorithms!\r\n   *\r\n   * @param grid the grid that the maze shall be generated to\r\n   */\r\n  generateMaze(grid) {}\r\n\r\n  /**\r\n   *\r\n   * Prepare the grid for the maze generation,\r\n   * returns unvisited & visited arrays while also cleaning all obstacles from the map\r\n   *\r\n   * @param grid the grid that the maze shall be generated to\r\n   */\r\n  prepareForAlgorithmCalculation(grid) {\r\n    const { startPoint, endPoint } = super.prepareForAlgorithmCalculation(grid);\r\n\r\n    // start with cleaning all obstacles\r\n    grid.clearAllObjects(ObjectTypes.obstacle);\r\n\r\n    // start the array with the start point as first element\r\n    const visited = [startPoint];\r\n\r\n    return {\r\n      visited,\r\n      rewindStack: [],\r\n      startPoint,\r\n      endPoint\r\n    };\r\n  }\r\n\r\n  prepareCellForAlgorithmCalculation(cell) {\r\n    super.prepareCellForAlgorithmCalculation(cell);\r\n\r\n    cell.mazeData = {};\r\n  }\r\n\r\n  /**\r\n   *\r\n   * return an empty random cell on the grid\r\n   *\r\n   * @param grid the grid that the maze shall be generated to\r\n   */\r\n  getRandomEmptyCell(grid) {\r\n    let cell = undefined;\r\n    while (!cell || cell.objectType !== ObjectTypes.empty) {\r\n      cell = sample(grid.cells);\r\n    }\r\n\r\n    return cell;\r\n  }\r\n\r\n  /**\r\n   * In case we are using 'Strict Blockwise' method (calculate skipping 2 cells at a time)\r\n   * we want to be able to get the cell between these cells\r\n   * @param cellA\r\n   * @param cellB\r\n   */\r\n  getCellBetweenCells(cellA, cellB) {\r\n    const { dirX, dirY } = clampDirectionToOne(\r\n      cellA.x - cellB.x,\r\n      cellA.y - cellB.y\r\n    );\r\n\r\n    const inBetweenCell = cellB.getNeighborAtUnitsDirection(dirX, dirY);\r\n\r\n    return inBetweenCell;\r\n  }\r\n}\r\n","export function clampDirectionToOne(dirX, dirY) {\r\n  dirX = dirX > 1 ? 1 : dirX < -1 ? -1 : dirX;\r\n  dirY = dirY > 1 ? 1 : dirY < -1 ? -1 : dirY;\r\n\r\n  return { dirX, dirY };\r\n}\r\n","import sample from \"lodash.sample\";\r\nimport BaseMazeAlgorithm from \"./BaseMazeAlgorithm\";\r\n\r\nexport default class RecursiveBacktracking extends BaseMazeAlgorithm {\r\n  /**\r\n   *\r\n   * Simulate maze generation using recursive backtracking algorithm.\r\n   *\r\n   * @param grid the grid that the maze shall be generated to\r\n   */\r\n  generateMaze(grid) {\r\n    // prepare grid for maze generation!\r\n    let {\r\n      visited,\r\n      rewindStack,\r\n      startPoint\r\n    } = this.prepareForAlgorithmCalculation(grid);\r\n\r\n    const stack = [];\r\n\r\n    this.recursiveMove(startPoint, stack, visited, rewindStack);\r\n\r\n    return {\r\n      openCells: visited,\r\n      rewindStack\r\n    };\r\n  }\r\n\r\n  recursiveMove(cell, stack, visited, rewindStack) {\r\n    rewindStack.push(cell); // push to rewind stack\r\n\r\n    const neighbors = cell.getNeighbors(2);\r\n\r\n    const movableNeighbors = neighbors.filter(neighbor =>\r\n      this.isValidMove(neighbor, visited)\r\n    );\r\n\r\n    // all of our paths are blocked, go back! (backtracking)\r\n    if (movableNeighbors.length === 0) {\r\n      // if we are back to the starting point then the generation is over.\r\n      if (stack.length === 0) return true;\r\n\r\n      return this.recursiveMove(stack.pop(), stack, visited, rewindStack);\r\n    }\r\n\r\n    // get a random movement and setup\r\n    let randomMove = sample(movableNeighbors);\r\n\r\n    const randomMoveCell = randomMove.cell;\r\n    stack.push(randomMoveCell);\r\n    visited.push(randomMoveCell);\r\n\r\n    const inBetweenCell = this.getCellBetweenCells(cell, randomMoveCell);\r\n\r\n    visited.push(inBetweenCell);\r\n    rewindStack.push(inBetweenCell);\r\n\r\n    return this.recursiveMove(randomMoveCell, stack, visited, rewindStack);\r\n  }\r\n\r\n  // allow movement only if wasn't checked before\r\n  isValidMove(neighbor, visited) {\r\n    return !visited.includes(neighbor.cell);\r\n  }\r\n}\r\n","import Manager from \"../../manager\";\r\nimport PathFinder from \"../pathFinding/pathfinder\";\r\nimport ObjectTypes from \"../../grid/objectTypes\";\r\n\r\nimport RecruisiveBacktracing from \"./algorithms/RecursiveBacktracking\";\r\n\r\nimport sleep from \"../../sleepUtility\";\r\nimport Config from \"../../../config\";\r\n\r\nconst currentAlgorithm = new RecruisiveBacktracing();\r\n\r\nconst generateMaze = async function() {\r\n  const algorithm = this.currentAlgorithm;\r\n\r\n  if (!algorithm) return;\r\n\r\n  Manager.grid.setSimulationState(true);\r\n\r\n  // clear path finder first so that we don't cause any issues\r\n  PathFinder.clearPath();\r\n\r\n  const grid = Manager.grid;\r\n  const { openCells, rewindStack } = algorithm.generateMaze(grid);\r\n\r\n  await drawRewind(grid, openCells, rewindStack, algorithm);\r\n\r\n  Manager.grid.setSimulationState(false);\r\n};\r\n\r\nconst drawRewind = function(grid, visited, rewindStack, algorithm) {\r\n  const delay = Config.grid.simulationPlaybackDelay * 4;\r\n\r\n  if (algorithm.passageCarver) {\r\n    return passageCarverRewind(grid, visited, rewindStack, delay);\r\n  }\r\n\r\n  return wallAdderRewind(grid, visited, rewindStack, delay);\r\n};\r\n\r\nconst passageCarverRewind = function(grid, visited, rewindStack, delay) {\r\n  return new Promise(async res => {\r\n    // start with setting all cells color to route color &\r\n    // assigning all empty cells to obstacles\r\n    for (let cell of grid.cells) {\r\n      if (cell.objectType !== ObjectTypes.empty) continue;\r\n\r\n      cell.cellColor = Config.rewind.routeColor;\r\n      cell.objectType = ObjectTypes.obstacle;\r\n    }\r\n\r\n    // iterate the rewind stack and set each rewinded cell color to the rewind color\r\n    // after a certain delay, reset the cell color and if its an obstacle cell (not a flag/ home)\r\n    // set the object type to empty -> meaning, clear the cell/ create a passage\r\n    for (let cell of rewindStack) {\r\n      cell.cellColor = Config.rewind.rewindColor;\r\n\r\n      await sleep(delay);\r\n\r\n      cell.resetCellColor();\r\n\r\n      // clear the actual cell\r\n      if (!visited.includes(cell) || cell.objectType !== ObjectTypes.obstacle)\r\n        continue;\r\n\r\n      cell.objectType = ObjectTypes.empty;\r\n    }\r\n\r\n    // to finish it off, clear the cell color of all cells\r\n    for (let cell of grid.cells) {\r\n      cell.resetCellColor();\r\n    }\r\n\r\n    res();\r\n  });\r\n};\r\n\r\nconst wallAdderRewind = function(grid, visited, rewindStack, delay) {\r\n  return new Promise(async res => {\r\n    // iterate the rewind stack and set each rewinded cell color to the rewind color\r\n    // after a certain delay, reset the cell color and if its an obstacle cell (not a flag/ home)\r\n    // set the object type to empty -> meaning, clear the cell/ create a passage\r\n    for (let cell of rewindStack) {\r\n      cell.cellColor = Config.rewind.rewindColor;\r\n\r\n      await sleep(delay);\r\n\r\n      cell.resetCellColor();\r\n\r\n      // clear the actual cell\r\n      if (!visited.includes(cell) || cell.objectType !== ObjectTypes.empty)\r\n        continue;\r\n\r\n      cell.objectType = ObjectTypes.obstacle;\r\n    }\r\n\r\n    // to finish it off, clear the cell color of all cells\r\n    for (let cell of grid.cells) {\r\n      cell.resetCellColor();\r\n    }\r\n\r\n    res();\r\n  });\r\n};\r\n\r\nexport default {\r\n  currentAlgorithm,\r\n  generateMaze,\r\n  drawRewind,\r\n  passageCarverRewind,\r\n  wallAdderRewind\r\n};\r\n","import BaseMazeAlgorithm from \"./BaseMazeAlgorithm\";\r\n\r\n/**\r\n * According to some articles 'Eller's Algorithm' is the most difficult and fastest\r\n * maze generation algorithm nowadays.\r\n *\r\n * the way it works:\r\n *\r\n * 1. Get the first row and give each cell a unique 'set' (an identifier)\r\n * 2. Merge random adjacent cells of the current row and combine the sets.\r\n * 3. Create random vertical connections to the row under (at least one for each set)\r\n * 4. Go down a row and populate their sets\r\n * 5. Repeat from 2.\r\n * 6. When reaching the end set, repeat 2 and skip vertical connections.\r\n * 7. DONE.\r\n *\r\n */\r\nexport default class EllersAlgorithm extends BaseMazeAlgorithm {\r\n  /**\r\n   * generate the maze,\r\n   * returns ->\r\n   *\r\n   * rewind cells array\r\n   * openCells array\r\n   * @param grid\r\n   */\r\n  generateMaze(grid) {\r\n    // prepare grid for maze generation!\r\n    let { rewindStack } = this.prepareForAlgorithmCalculation(grid);\r\n\r\n    const sets = {}; // create a hash table for all sets\r\n    const cellsToSets = {}; // start a hash table for all cells to sets\r\n    const setsCounter = 0; // start the sets counter from 0\r\n\r\n    // start from the first row! (strict block wise implementation)\r\n    this.generateRow(grid, 1, cellsToSets, sets, setsCounter, rewindStack);\r\n\r\n    return {\r\n      openCells: rewindStack,\r\n      rewindStack\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param grid The grid\r\n   * @param rowId The current row\r\n   * @param cellsToSets An hash table that keeps hold of every cell and the set it belongs to\r\n   * @param sets An hash table of all sets in the calculation thus far and cells that belong to it\r\n   * @param setsCounter A simple sets counter that keep track of last sets index\r\n   * @param rewindStack An array that keeps track of the progress during the calculation\r\n   */\r\n  generateRow(grid, rowId, cellsToSets, sets, setsCounter, rewindStack) {\r\n    const cells = this.getRowCells(grid, rowId);\r\n\r\n    // row below is row + 2 because we are using strict blockwise in which cell has 4 cells surrounding it that acts as walls\r\n    const rowBelow = rowId + 2;\r\n    const isLastRow = rowBelow >= grid.height;\r\n\r\n    // populate sets for unassigned cells in this row\r\n    setsCounter = this.assignSetsToUnassignedCells(\r\n      cells,\r\n      cellsToSets,\r\n      sets,\r\n      setsCounter,\r\n      rewindStack\r\n    );\r\n\r\n    // combine adjacent cells in this row\r\n    this.combineAdjacentCellsInRow(\r\n      grid,\r\n      cells,\r\n      cellsToSets,\r\n      sets,\r\n      rewindStack,\r\n      isLastRow\r\n    );\r\n\r\n    if (isLastRow) return true; // done!\r\n\r\n    this.combineVerticalCellsInRowUnder(\r\n      grid,\r\n      rowId,\r\n      rowBelow,\r\n      cellsToSets,\r\n      sets,\r\n      setsCounter,\r\n      rewindStack\r\n    );\r\n\r\n    // recursive\r\n    return this.generateRow(\r\n      grid,\r\n      rowBelow,\r\n      cellsToSets,\r\n      sets,\r\n      setsCounter,\r\n      rewindStack\r\n    );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param cells the cells of the row\r\n   * @param cellsToSets the cells to set array thus far\r\n   * @param sets an array that keeps track of all sets thus far\r\n   * @param sets A simple sets counter that keep track of last sets index\r\n   */\r\n  assignSetsToUnassignedCells(\r\n    cells,\r\n    cellsToSets,\r\n    sets,\r\n    setsCounter,\r\n    rewindStack\r\n  ) {\r\n    for (let cell of cells) {\r\n      // complexity according to stackoverflow -> O(1)\r\n      if (cellsToSets.hasOwnProperty(cell.index)) continue; // if we already have a set assigned to this cell continue\r\n\r\n      // assign the cell to the new set\r\n      this.addToSet(cell, setsCounter, sets, cellsToSets);\r\n\r\n      setsCounter++;\r\n\r\n      // open the cell\r\n      rewindStack.push(cell);\r\n    }\r\n\r\n    return setsCounter;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * After we have assigned sets, randomly combine adjacent cells\r\n   *\r\n   * @param cells\r\n   * @param cellsToSets\r\n   * @param sets\r\n   * @param rewindStack\r\n   * @param isLastRow is this the last row?\r\n   */\r\n  combineAdjacentCellsInRow(\r\n    grid,\r\n    cells,\r\n    cellsToSets,\r\n    sets,\r\n    rewindStack,\r\n    isLastRow\r\n  ) {\r\n    for (let cell of cells) {\r\n      const nextCell = grid.getCell(cell.x + 2, cell.y); // adjust with two as we are using strict blockwise implementation\r\n      if (!nextCell) continue;\r\n\r\n      // if we are in the last row combine adjacent cells no matter what, if not, use a random value\r\n      if (this.getRndTrueFalse() && !isLastRow) continue;\r\n\r\n      const currCellSet = cellsToSets[cell.index];\r\n      const nextCellSet = cellsToSets[nextCell.index];\r\n\r\n      if (currCellSet === nextCellSet) continue; // don't merge cells from the same set\r\n\r\n      this.mergeSets(nextCellSet, currCellSet, sets, cellsToSets);\r\n      //}\r\n\r\n      // get the cell between these cells and open a passage between them!\r\n      const betweenCell = this.getCellBetweenCells(cell, nextCell);\r\n      if (!betweenCell) continue; // incase of an error\r\n\r\n      rewindStack.push(betweenCell);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Calculate vertical cells passages a row under current row\r\n   *\r\n   * @param grid\r\n   * @param rowBelowId\r\n   * @param cellsToSets\r\n   * @param sets\r\n   * @param setsCounter the counter of sets\r\n   * @param rewindStack\r\n   */\r\n  combineVerticalCellsInRowUnder(\r\n    grid,\r\n    currRowId,\r\n    rowBelowId,\r\n    cellsToSets,\r\n    sets,\r\n    setsCounter,\r\n    rewindStack\r\n  ) {\r\n    // iterate through all possible sets\r\n    for (let set = 0; set <= setsCounter; set++) {\r\n      if (!sets.hasOwnProperty(set)) continue; // make sure this set exists as when a cell merges it disappears\r\n\r\n      const setCells = sets[set];\r\n      if (!setCells || setCells.length === 0) continue; // maybe some how this set is empty, continue\r\n\r\n      // make sure that there's at least 1 vertical connection\r\n      let verticalConnections = 0;\r\n      while (verticalConnections === 0) {\r\n        // the reason we copy the set cells is because we are altering the original array within the function\r\n        // by adding items to it which could cause incorrect iterations if we iterate over the original array.\r\n        const copiedSetCells = [...setCells];\r\n        for (let cellIndex of copiedSetCells) {\r\n          if (this.getRndTrueFalse()) continue; // random\r\n\r\n          const cell = grid.cells[cellIndex];\r\n          if (!cell || cell.y !== currRowId) continue; // only work with cells from the current row\r\n\r\n          // get under by two\r\n          const belowCell = grid.getCell(cell.x, rowBelowId);\r\n          if (!belowCell) continue; // incase of an error\r\n\r\n          // assign the vertical cell to the set\r\n          this.addToSet(belowCell, set, sets, cellsToSets);\r\n          rewindStack.push(belowCell); // add to rewind stack so that it gets marked as open\r\n\r\n          const betweenCell = this.getCellBetweenCells(cell, belowCell);\r\n          if (!betweenCell) continue; // incase of an error\r\n\r\n          rewindStack.push(betweenCell); // add to rewind stack so that it gets marked as open\r\n          verticalConnections++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Adds a certain cell to a set\r\n   *\r\n   * @param cell\r\n   * @param set\r\n   * @param sets\r\n   * @param cellsToSets\r\n   */\r\n  addToSet(cell, set, sets, cellsToSets) {\r\n    const cellIndex = cell.index;\r\n\r\n    cellsToSets[cellIndex] = set;\r\n\r\n    if (!sets.hasOwnProperty(set)) {\r\n      // create a new array\r\n      sets[set] = [];\r\n    }\r\n\r\n    sets[set].push(cellIndex);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * merge a set into another set\r\n   *\r\n   * @param fromSet the set that needs to get merged\r\n   * @param toSet the set you want to merge to\r\n   * @param sets the overall sets hashtable\r\n   * @param cellsToSets the cells to sets hashtable\r\n   */\r\n  mergeSets(fromSet, toSet, sets, cellsToSets) {\r\n    const fromSetCells = sets[fromSet];\r\n    const toSetCells = sets[toSet];\r\n\r\n    if (!fromSetCells)\r\n      throw Error(\r\n        \"Can't merge cells as from set cells aren't found \" + fromSet\r\n      );\r\n\r\n    if (!toSetCells)\r\n      throw Error(\"Can't merge cells as to set cells aren't found \" + toSet);\r\n\r\n    for (let fromSetCell of fromSetCells) {\r\n      toSetCells.push(fromSetCell);\r\n      cellsToSets[fromSetCell] = toSet;\r\n    }\r\n\r\n    // revoke the from set reference as its not used anymore\r\n    sets[fromSet] = undefined;\r\n  }\r\n\r\n  /**\r\n   * get the cells of that row\r\n   * @param grid grid\r\n   * @param rowId What row?\r\n   */\r\n  getRowCells(grid, rowId) {\r\n    return grid.getRowCells(rowId, 1, grid.width - 1, 2);\r\n  }\r\n\r\n  /**\r\n   * This method returns a random true/ false value\r\n   */\r\n  getRndTrueFalse() {\r\n    return Math.random() <= 0.5;\r\n  }\r\n}\r\n","import BaseMazeAlgorithm from \"./BaseMazeAlgorithm\";\r\n\r\nexport default class RecursiveDivisionAlgorithm extends BaseMazeAlgorithm {\r\n  horizontal = \"horizontal\";\r\n  vertical = \"vertical\";\r\n  maxDetail = 2;\r\n\r\n  passageCarver = false; // we create walls, not open them\r\n\r\n  /**\r\n   *\r\n   * Simulate maze generation using recursive division algorithm.\r\n   *\r\n   * The way it works is by recursively crossing a random line through a specified x, y, width, height coordinates.\r\n   *\r\n   * @param grid the grid that the maze shall be generated to\r\n   */\r\n  generateMaze(grid) {\r\n    // prepare grid for maze generation!\r\n    let { visited } = this.prepareForAlgorithmCalculation(grid);\r\n\r\n    this.closeOffAllBoarders(grid, visited);\r\n\r\n    this.simpleRecursiveMove(\r\n      grid,\r\n      1,\r\n      1,\r\n      grid.width - 1,\r\n      grid.height - 1,\r\n      visited,\r\n      true\r\n    );\r\n\r\n    return {\r\n      openCells: visited,\r\n      rewindStack: visited\r\n    };\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Basic recursive move that automatically determines cross orientation\r\n   *\r\n   * @param grid\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   * @param visited\r\n   */\r\n  simpleRecursiveMove(grid, x, y, width, height, visited, initialRun = false) {\r\n    this.recursiveMove(\r\n      grid,\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n      visited,\r\n      this.determineCrossDirection(width, height, initialRun)\r\n    );\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Recursively cross a line with a specified orientation and proceeds with further subfields\r\n   *\r\n   * @param grid\r\n   * @param x\r\n   * @param y\r\n   * @param width\r\n   * @param height\r\n   * @param visited\r\n   * @param orientation\r\n   */\r\n  recursiveMove(grid, x, y, width, height, visited, orientation) {\r\n    if (width <= this.maxDetail || height <= this.maxDetail) return;\r\n\r\n    const horizontal = orientation === this.horizontal;\r\n\r\n    // w coordinates => wall units\r\n    let wx = x + (horizontal ? 0 : this.getRand(width - 2));\r\n    let wy = y + (horizontal ? this.getRand(height - 2) : 0);\r\n\r\n    // p coordinages => passage units\r\n    const px = wx + (horizontal ? this.getRand(width) : 0);\r\n    const py = wy + (horizontal ? 0 : this.getRand(height));\r\n\r\n    // this makes sure that all units are allowed meaning the wall unit is even and the passage unit isn't even\r\n    // so that we don't cover a passage with a wall\r\n    if (!this.areUnitsAllowed(wx, wy, px, py, horizontal))\r\n      return this.recursiveMove(\r\n        grid,\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        visited,\r\n        orientation\r\n      );\r\n\r\n    // get the movement direction\r\n    const direction = {\r\n      x: horizontal ? 1 : 0,\r\n      y: horizontal ? 0 : 1\r\n    };\r\n\r\n    // what is the length of the future wall ?\r\n    const length = horizontal ? width : height;\r\n\r\n    // mark the cells as walls\r\n    for (let i = 0; i < length; i++) {\r\n      const cell = grid.getCell(wx, wy);\r\n      if (!cell) break;\r\n\r\n      if (!(wx === px && wy === py)) {\r\n        visited.push(cell);\r\n      }\r\n\r\n      wx += direction.x;\r\n      wy += direction.y;\r\n    }\r\n\r\n    // create sub bounds!\r\n\r\n    // first one ->\r\n    let nx = x;\r\n    let ny = y;\r\n\r\n    // we are adding extra unit because when we randomize the wx&wy units we remove 2 units from the calculation.\r\n    let nw = horizontal ? width : wx - x + 1;\r\n    let nh = horizontal ? wy - y + 1 : height;\r\n\r\n    this.simpleRecursiveMove(grid, nx, ny, nw, nh, visited);\r\n\r\n    // second one ->\r\n    nx = horizontal ? x : wx + 1;\r\n    ny = horizontal ? wy + 1 : y;\r\n\r\n    nw = horizontal ? width : x + width - wx - 1;\r\n    nh = horizontal ? y + height - wy - 1 : height;\r\n\r\n    this.simpleRecursiveMove(grid, nx, ny, nw, nh, visited);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Determine in which direction we want to cross the grid, generally to create good looking mazes with as many less weird parts as possible\r\n   * we would want to have the orientation set to horizontal if the width is smaller than the height and if the opposite, set to vertical crossing\r\n   *\r\n   * TODO: initial should be random\r\n   *\r\n   * @param width\r\n   * @param height\r\n   */\r\n  determineCrossDirection(width, height, initialRun) {\r\n    if (initialRun)\r\n      return Math.random() >= 0.5 ? this.horizontal : this.vertical;\r\n\r\n    return width < height ? this.horizontal : this.vertical;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Pre generation, close off all of the walls\r\n   *\r\n   * @param grid\r\n   * @param visited\r\n   */\r\n  closeOffAllBoarders(grid, visited) {\r\n    const { width, height } = grid;\r\n    for (let cell of grid.cells) {\r\n      if (cell.x > 0 && cell.x < width - 1 && cell.y > 0 && cell.y < height - 1)\r\n        continue;\r\n\r\n      visited.push(cell);\r\n    }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Get a random 0 -> max value\r\n   *\r\n   * @param max\r\n   */\r\n  getRand(max) {\r\n    return Math.floor(max * Math.random());\r\n  }\r\n\r\n  /**\r\n   *\r\n   * Checks if the proper wall unit is even and proper passage unit isn't even to make sure the units won't overlap with passage units.\r\n   *\r\n   * @param wx\r\n   * @param wy\r\n   * @param px\r\n   * @param py\r\n   * @param isHorizontal\r\n   */\r\n  areUnitsAllowed(wx, wy, px, py, isHorizontal) {\r\n    if (isHorizontal) {\r\n      return wy % 2 === 0 && px % 2 !== 0;\r\n    }\r\n\r\n    return wx % 2 === 0 && py % 2 !== 0;\r\n  }\r\n}\r\n","import React from \"react\";\r\n\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport FormControl from \"@material-ui/core/FormControl\";\r\nimport Select from \"@material-ui/core/Select\";\r\n\r\nimport MazeGenerator from \"../../../logic/Algorithms/mazeGeneration/mazeGenerator\";\r\n\r\nimport RecrusiveBacktrackingAlgorithm from \"../../../logic/Algorithms/mazeGeneration/algorithms/RecursiveBacktracking\";\r\nimport EllerMazeAlgorithm from \"../../../logic/Algorithms/mazeGeneration/algorithms/EllerMazeAlgorithm\";\r\nimport RecursiveDivisionAlgorithm from \"../../../logic/Algorithms/mazeGeneration/algorithms/RecursiveDivisionAlgorithm\";\r\n\r\nconst algorithms = [\r\n  new RecrusiveBacktrackingAlgorithm(),\r\n  new EllerMazeAlgorithm(),\r\n  new RecursiveDivisionAlgorithm()\r\n];\r\n\r\nexport default function MazeAlgorithmSelect(props) {\r\n  const [selectedAlgo, setAlgo] = React.useState(0);\r\n\r\n  const changeHandler = event => {\r\n    setAlgo(event.target.value);\r\n\r\n    MazeGenerator.currentAlgorithm = algorithms[event.target.value];\r\n  };\r\n\r\n  return (\r\n    <FormControl className=\"SelectForm MiddleItem\">\r\n      <Select\r\n        labelId=\"algorithm-selector\"\r\n        id=\"algorithm-selector-select\"\r\n        value={selectedAlgo}\r\n        onChange={changeHandler}\r\n        className=\"SelectBox\"\r\n        disabled={!props.isUsable}\r\n      >\r\n        <MenuItem value={0} className=\"SelectMenuItem\">\r\n          Recursive Backtracking\r\n        </MenuItem>\r\n        <MenuItem value={1} className=\"SelectMenuItem\">\r\n          Eller's Algorithm\r\n        </MenuItem>\r\n        <MenuItem value={2} className=\"SelectMenuItem\">\r\n          Recursive Division\r\n        </MenuItem>\r\n      </Select>\r\n    </FormControl>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport MenuItem from \"@material-ui/core/MenuItem\";\r\nimport FormControl from \"@material-ui/core/FormControl\";\r\nimport Select from \"@material-ui/core/Select\";\r\n\r\nimport Config from \"../../../config\";\r\n\r\nconst speeds = [10, 1, 25];\r\n\r\nexport default function SimulationSpeedSelect(props) {\r\n  const [selectedSpeed, setSelectedSpeed] = React.useState(0);\r\n\r\n  const changeHandler = event => {\r\n    const value = event.target.value;\r\n\r\n    setSelectedSpeed(value);\r\n    Config.grid.simulationPlaybackDelay = speeds[value];\r\n  };\r\n\r\n  return (\r\n    <FormControl className=\"SelectForm MiddleItem\">\r\n      <Select\r\n        labelId=\"speed-selector\"\r\n        id=\"speed-selector-select\"\r\n        value={selectedSpeed}\r\n        onChange={changeHandler}\r\n        className=\"SelectBox\"\r\n        disabled={!props.isUsable}\r\n      >\r\n        <MenuItem value={0} className=\"SelectMenuItem\">\r\n          Normal\r\n        </MenuItem>\r\n        <MenuItem value={1} className=\"SelectMenuItem\">\r\n          Fast\r\n        </MenuItem>\r\n        <MenuItem value={2} className=\"SelectMenuItem\">\r\n          Slow\r\n        </MenuItem>\r\n      </Select>\r\n    </FormControl>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { Button } from \"@material-ui/core\";\r\n\r\nimport PathFinder from \"../../../logic/Algorithms/pathFinding/pathfinder\";\r\n\r\nexport default function SimulatePathButton(props) {\r\n  const handleClick = () => {\r\n    PathFinder.simulatePath(true);\r\n  };\r\n\r\n  return (\r\n    <Button\r\n      variant=\"contained\"\r\n      color=\"primary\"\r\n      disabled={!props.isUsable}\r\n      className=\"RightItem\"\r\n      onClick={handleClick}\r\n    >\r\n      Simulate Path\r\n    </Button>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { Button } from \"@material-ui/core\";\r\n\r\nimport MazeGenerator from \"../../../logic/Algorithms/mazeGeneration/mazeGenerator\";\r\n\r\nexport default function SimulateMazeButton(props) {\r\n  const handleClick = () => {\r\n    MazeGenerator.generateMaze();\r\n  };\r\n\r\n  return (\r\n    <Button\r\n      variant=\"contained\"\r\n      color={\"primary\"}\r\n      disabled={!props.isUsable}\r\n      className=\"RightItem\"\r\n      onClick={handleClick}\r\n    >\r\n      Simulate Maze\r\n    </Button>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport { Button } from \"@material-ui/core\";\r\n\r\nimport Manager from \"../../../logic/manager\";\r\nimport PathFinder from \"../../../logic/Algorithms/pathFinding/pathfinder\";\r\n\r\nexport default function ClearButton(props) {\r\n  const handleClick = () => {\r\n    PathFinder.clearPath();\r\n    Manager.grid.clearObjects();\r\n    Manager.grid.spawnDefaultItems();\r\n  };\r\n\r\n  return (\r\n    <Button\r\n      variant=\"contained\"\r\n      color=\"secondary\"\r\n      disabled={!props.isUsable}\r\n      className=\"RightItem\"\r\n      onClick={handleClick}\r\n    >\r\n      Clear\r\n    </Button>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport Logo from \"./subTypes/logo\";\r\nimport ObstacleToggle from \"./subTypes/obstacleToggle\";\r\n\r\nimport PathAlgorithmSelect from \"./subTypes/pathAlgorithmSelect\";\r\nimport MazeAlgorithmSelect from \"./subTypes/mazeAlgorithmSelect\";\r\nimport SimulationSpeedSelect from \"./subTypes/simulationSpeedSelect\";\r\n\r\nimport SimulatePathButton from \"./subTypes/simulatePathButton\";\r\nimport SimulateMazeButton from \"./subTypes/simulateMazeButton\";\r\nimport ClearButton from \"./subTypes/clearButton\";\r\n\r\nimport \"../../styling/header.css\";\r\n\r\nexport default function HeaderComponent(props) {\r\n  return (\r\n    <div id=\"header\" disabled={true}>\r\n      <span className=\"LeftItems\">\r\n        <Logo></Logo>\r\n\r\n        <ObstacleToggle isUsable={props.isUsable} className=\"LeftItem\" />\r\n        <PathAlgorithmSelect isUsable={props.isUsable} className=\"LeftItem\" />\r\n        <MazeAlgorithmSelect isUsable={props.isUsable} className=\"LeftItem\" />\r\n        <SimulationSpeedSelect isUsable={props.isUsable} className=\"LeftItem\" />\r\n      </span>\r\n      <span className=\"RightItems\">\r\n        <SimulatePathButton isUsable={props.isUsable} />\r\n        <SimulateMazeButton isUsable={props.isUsable} />\r\n        <ClearButton isUsable={props.isUsable} />\r\n      </span>\r\n    </div>\r\n  );\r\n}\r\n","export default function getCellDOMId(x, y) {\r\n  return \"x:\" + x + \"y:\" + y;\r\n}\r\n","import React from \"react\";\r\n\r\nimport ObjectTypes from \"../../../logic/grid/objectTypes\";\r\nimport { useDrag } from \"react-dnd\";\r\n\r\nimport startPoint from \"../../../styling/design/blocks/startPoint.png\";\r\n\r\nexport default function StartPoint(props) {\r\n  const [{ isDragging }, drag] = useDrag({\r\n    item: { type: ObjectTypes.startPoint },\r\n    collect: monitor => ({\r\n      isDragging: !!monitor.isDragging()\r\n    })\r\n  });\r\n\r\n  return (\r\n    <img\r\n      ref={drag}\r\n      style={{\r\n        opacity: isDragging ? 0.5 : 1,\r\n        cursor: \"move\"\r\n      }}\r\n      alt=\"start point\"\r\n      src={startPoint}\r\n      className=\"cellObject\"\r\n    ></img>\r\n  );\r\n}\r\n","import React from \"react\";\r\nimport obstacle from \"../../../styling/design/blocks/obstacle.png\";\r\n\r\nexport default function Obstacle() {\r\n  return (\r\n    <img alt=\"obstacle\" src={obstacle} className=\"cellObject obstacle\"></img>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport ObjectTypes from \"../../../logic/grid/objectTypes\";\r\nimport { useDrag } from \"react-dnd\";\r\n\r\nimport endPoint from \"../../../styling/design/blocks/endPoint.png\";\r\n\r\nexport default function EndPoint() {\r\n  const [{ isDragging }, drag] = useDrag({\r\n    item: { type: ObjectTypes.endPoint },\r\n    collect: monitor => ({\r\n      isDragging: !!monitor.isDragging()\r\n    })\r\n  });\r\n\r\n  return (\r\n    <img\r\n      ref={drag}\r\n      style={{\r\n        opacity: isDragging ? 0.5 : 1,\r\n        cursor: \"move\"\r\n      }}\r\n      alt=\"end point\"\r\n      src={endPoint}\r\n      className=\"cellObject\"\r\n    ></img>\r\n  );\r\n}\r\n","import React from \"react\";\r\n\r\nimport StartPoint from \"./startPoint\";\r\nimport Obstacle from \"./obstacle\";\r\nimport EndPoint from \"./endPoint\";\r\n\r\nimport ObjectTypes from \"../../../logic/grid/objectTypes\";\r\n\r\nexport default function CellObjectDrawer(props) {\r\n  switch (props.object) {\r\n    case ObjectTypes.startPoint:\r\n      return <StartPoint></StartPoint>;\r\n\r\n    case ObjectTypes.endPoint:\r\n      return <EndPoint></EndPoint>;\r\n\r\n    case ObjectTypes.obstacle:\r\n      return <Obstacle></Obstacle>;\r\n\r\n    default:\r\n      return \"\";\r\n  }\r\n}\r\n","import React from \"react\";\r\n\r\nimport { useDrop } from \"react-dnd\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\n\r\nimport Manager from \"../../logic/manager\";\r\nimport ObjectDrawer from \"./objects/objectDrawer\";\r\nimport ObjectTypes from \"../../logic/grid/objectTypes\";\r\n\r\nimport { isMobile } from \"react-device-detect\";\r\nimport getCellDOMId from \"../../logic/cellNamingUtility\";\r\n\r\nconst toolbarSettings = require(\"../header/toolbarSettings\");\r\n\r\nconst cellWidth = isMobile ? 25 : 50;\r\nconst marginSpace = (window.innerWidth - Manager.grid.width * cellWidth) / 2;\r\n\r\nconst useStyle = makeStyles({\r\n  root: {\r\n    // removing background assigning from here as we won't need that anymore,\r\n    // assigning directly to the DOM from the grid.jsx - on cell color updated event\r\n    //backgroundColor: data => data.cellColor,\r\n    width: cellWidth,\r\n    height: cellWidth,\r\n    marginLeft: marginSpace,\r\n    left: data => data.x * cellWidth,\r\n    top: data => data.y * cellWidth\r\n  }\r\n});\r\n\r\nexport default function CellComponent(props) {\r\n  //#region Drag and Drop Implementation\r\n\r\n  const [, drop] = useDrop({\r\n    accept: [ObjectTypes.startPoint, ObjectTypes.endPoint],\r\n    drop: dropProps => {\r\n      const objectType = dropProps.type;\r\n      Manager.grid.moveItemToCell(objectType, props.data);\r\n    },\r\n    canDrop: () => props.data.objectType === ObjectTypes.empty && props.isUsable\r\n  });\r\n\r\n  //#endregion\r\n\r\n  //#region events handlers\r\n\r\n  const handleMouseHeld = e => {\r\n    if (e.buttons !== 1) return;\r\n    handlePaintObject(true);\r\n  };\r\n\r\n  const handleMousePress = () => {\r\n    handlePaintObject(false);\r\n  };\r\n\r\n  const handlePaintObject = function(isHoldingMouse) {\r\n    if (!props.isUsable) return;\r\n\r\n    const { x, y, objectType } = props.data;\r\n\r\n    // can't paint these types\r\n    if (\r\n      objectType === ObjectTypes.startPoint ||\r\n      objectType === ObjectTypes.endPoint\r\n    )\r\n      return;\r\n\r\n    let drawingObjectType = toolbarSettings.getSafeDrawingType();\r\n    const isSameObject = drawingObjectType === objectType;\r\n\r\n    if (isSameObject) {\r\n      // if we are not changing the object while holding mouse, return\r\n      if (isHoldingMouse) return;\r\n\r\n      drawingObjectType = ObjectTypes.empty; // else, flip back to no object\r\n    }\r\n\r\n    const cell = Manager.grid.getCell(x, y);\r\n    cell.objectType = drawingObjectType;\r\n  };\r\n\r\n  //#endregion\r\n\r\n  const cssClasses = useStyle(props.data);\r\n\r\n  return (\r\n    <div\r\n      ref={drop}\r\n      className={cssClasses.root + \" cell\"}\r\n      id={getCellDOMId(props.data.x, props.data.y)}\r\n      onClick={handleMousePress}\r\n      onMouseMove={handleMouseHeld}\r\n    >\r\n      <div className=\"cellObjectsParent\">\r\n        <ObjectDrawer object={props.data.objectType}></ObjectDrawer>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { DndProvider } from \"react-dnd\";\r\n\r\nimport Manager from \"../../logic/manager\";\r\nimport Pathfinder from \"../../logic/Algorithms/pathFinding/pathfinder\";\r\nimport ObjectTypes from \"../../logic/grid/objectTypes\";\r\nimport getCellDOMId from \"../../logic/cellNamingUtility\";\r\nimport Config from \"../../config\";\r\n\r\nimport CellComponent from \"./cell\";\r\n\r\nimport \"../../styling/grid.css\";\r\n\r\nclass GridComponent extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // copy over path finding cells\r\n    const logicCells = Manager.grid.cells;\r\n    const cells = [];\r\n\r\n    for (let cell of logicCells) {\r\n      cells.push(cell.simplify());\r\n    }\r\n\r\n    this.state = {\r\n      cells\r\n    };\r\n\r\n    // when ever a cell color is changed, update the cell dom manually instead of the react component.\r\n    // much faster!\r\n    Manager.grid.eventEmitter.on(\"colorChange\", (cell, index) => {\r\n      const { x, y } = cell;\r\n      const cellId = getCellDOMId(x, y);\r\n\r\n      const element = document.getElementById(cellId);\r\n      element.style.backgroundColor = cell.cellColor;\r\n    });\r\n\r\n    // when the object is changed, redraw the react component and also resimulate the path if already simulated before\r\n    Manager.grid.eventEmitter.on(\"objectChange\", (cell, index, { oldType }) => {\r\n      // update the state!\r\n      this.setState(state => {\r\n        {\r\n          const { cells } = state;\r\n          cells[index] = cell.simplify();\r\n\r\n          return cells;\r\n        }\r\n      });\r\n\r\n      // if we the old type of the cell was start/end points don't resimulate path as that will cause an error ->\r\n      // simulating a path with one of them missing\r\n      if (\r\n        !Pathfinder.pathGenerated ||\r\n        oldType === ObjectTypes.startPoint ||\r\n        oldType === ObjectTypes.endPoint\r\n      )\r\n        return;\r\n\r\n      Pathfinder.simulatePath();\r\n    });\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <DndProvider backend={Config.getRndBackend()}>\r\n        <div className=\"grid\">\r\n          {this.state.cells.map((cell, key) => (\r\n            <CellComponent\r\n              key={key}\r\n              data={cell}\r\n              isUsable={this.props.isUsable}\r\n            ></CellComponent>\r\n          ))}\r\n        </div>\r\n      </DndProvider>\r\n    );\r\n  }\r\n}\r\n\r\nexport default GridComponent;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"./index.css\";\r\nimport App from \"./components/App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","import React, { useEffect } from \"react\";\r\n\r\nimport HeaderComponent from \"./header/header\";\r\nimport GridComponent from \"./grid/grid\";\r\n\r\nimport Manager from \"../logic/manager\";\r\n\r\nimport \"../styling/App.css\";\r\n\r\nexport default function App() {\r\n  const [isUsable, setIsUsable] = React.useState(-1);\r\n\r\n  /**\r\n   * Set interactable status (when not simulating path!)\r\n   */\r\n  useEffect(() => {\r\n    if (isUsable !== -1) return;\r\n    setIsUsable(true);\r\n\r\n    Manager.grid.eventEmitter.on(\"simulateChanged\", simulating => {\r\n      setIsUsable(!simulating);\r\n    });\r\n  }, [isUsable]);\r\n\r\n  return (\r\n    <div className=\"App\">\r\n      <HeaderComponent isUsable={isUsable}></HeaderComponent>\r\n      <GridComponent isUsable={isUsable}></GridComponent>\r\n    </div>\r\n  );\r\n}\r\n"],"sourceRoot":""}